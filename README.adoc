= Documenting a Block

== What you need to know

* Knowledge of the block. What it does, how it is programmed, how do you interface to it,
 and what are the configurable values.
* How Scribble "Sections" work. Sections are the "generators" which produce documentation text.
* The basics of Asciidoc. Asciidoc is the markup language used by Scribble.
* The Jinja template processor. While complex Sections can be written
 in Python, most Sections are more easily written as Jinja templates.

== Sections of a Document

Scribble organizes a document into Sections, where each Section produces
a piece of text and, optionally, invokes other Sections as subsections. When
all of the Sections are evaluated, the resulting text is assembled into an AsciiDoc document.

When creating documents for a new hardware block, we aren't creating a whole new document.
Rather, we are creating special Sections
which can be inserted into other documents.

These special Sections include:

 - An "Overview"" paragraph describing the block.
 - A "Programming" chapter describing how to use and program the block.
 This section describes the registers, the memory mapped addresses,
 and gives a detailed decription of how the block should be configured.
 - A "HardwareInterface" chapter describing how to interface to the block.
 This section describes the interrupts, clocks and signals used by the block.

Typically, these sections will live in the "components" directory, in a subdirectory
named after the block or device.

For example, a new design for a "Whizbang" would have three files inside the following directories:
```
    - docs/scribble
        - components
            - Whizbang
                - Overview.jinja2
                - Programming.jinja2
                - HardwareInterface.jinja2
```

=== What does a Section look like?

A Section can be implemented as a Jinja template or as a Python function.
In either case, it is invoked through Scribble's "Section" call.
```
Section("module name", scope, **context)
```
where:

[horizontal]
name:: is the python or jinja module name.
scope:: is a subtree (element) of the object model.
context:: are additional named values passed to the section.

When a section is written as a Jinja template, all the
named arguments are available as Jinja template variables.


=== "Overview" Paragraph

The overview is a simple paragraph describing the block.

It is usually written as a single Jinja template.
It doesn't need a lot of detail, but it isn't entirely static either.
For example, if there is more than one instance of the device, then this
section would mention how many there are.

As an example, in the file `Overview.jinja2` the following line would describe how many parallel ports are in the design.

----
The {{ product_name }} contains {{ devices | length | english_number }} Parallel I/O ports.
----

which would be displayed as:

----
The PIO Test Socket contains five Parallel I/O ports.
----

=== "Programming" Chapter
This chapter describes the device or block and how to use it.
For some devices, the Section can get quite large and include a hierarchy
of sections and subsections. For simpler blocks, it might be a single Jinja
template.


=== "HardwareInterface" Chapter


== Appendix: Jinja Templates

=== Overview
Jinja templates consist of text interspersed with Jinja control statements.
For a good introduction to Jinja, see the online https://jinja.palletsprojects.com/en/2.10.x/[Jinja Documentation].

When Scribble invokes a template, it passes a number of predefined variables and template functions.
These variables and functions are described below.

=== Scribble Variables in Templates
Any named parameter passed to
a Section() automatically becomes a Jinja template variable.

Thus, the call to a Jinja template "MyNewSection.jinja2"
```
Section(".MyNewSection", scope, name="Joe", **context)
```
will invoke the template "MyNewSection.jinja2",
passing it the variable "name" with the value of "Joe".
Note the template name ".MyNewSection" starts with a leading ".",
so it should be in the same directory as the caller.

==== Predefined Variables for Onboarding New Blocks
When documenting new blocks, each of the three sections will be passed the following predefined variables.


scope:: The primary element being described. Typically this will be
        based on the object model schema for the block.

devices:: If there are multiple instances of the block, then
  `devices` contains all of them.
   Typically, `scope` is used to describe what all the devices
   have in common, while `devices` is used to iterate through
   the instances describing the unique values of each.

product_name:: Generally, the new device will be part of a larger
  design. `product_name` denotes the name of the larger design.
  It is used mainly for titles, but it can be used by device sections
  to remind the reader of the overall context around the device.

==== Helper Functions for Displaying Device Data
In addition to the variables, Scribble defines a number of helper functions:


base_addr(device):: Returns the hex memory address of a device.

Figure(image_path, title="title", id=reference_id, width="50%")::
Inserts a figure into the document. If the image_path starts with `{here}`,
then the image file is in the same directory as the caller.
Currently supports svg and png.

RegisterMap(device):: Creates a register map of the device which can be used
  to display various tables.  Typically,

  {% set registers = RegisterMap(device) %}
  {{ registers.table() }}            {# Displays a register map table #}
  {{ registers.fields("ODATA") }}    {# Displays fields for register ODATA #}
  {{ registers.names | human_list }} {# Displays a list of register names #}


==== Jinja "Pipe" Expressions
And finally, Scribble provides Jinja "pipe" expressions to help with
grammar and formatting.

list | length::
returns the numeric size of a list
number | english_number::
returns the number as an english word.  Examples are 1-->"one",
10->"ten".
list | plural(single, multiple)::
Returns the "single" text if the list length is 1, or the
"plural" text if the list length is > 1.

list | human_list::
Converts the list into a comma separated english phrase.

num | human_size::
Displays the number with an appropriate binary prefix (eg. KiB).




